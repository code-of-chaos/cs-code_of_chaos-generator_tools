// ---------------------------------------------------------------------------------------------------------------------
// Imports
// ---------------------------------------------------------------------------------------------------------------------
using System.Text;

namespace CodeOfChaos.GeneratorTools;
// ---------------------------------------------------------------------------------------------------------------------
// Code
// ---------------------------------------------------------------------------------------------------------------------
public class GeneratorStringBuilder(int paddingChars = 4) {
    private readonly StringBuilder _builder = new();
    private readonly int _paddingChars = paddingChars > 0 ? paddingChars : 4;
    private int _indent;
    internal int IndentAmount {
        get => _indent;
        set => _indent = value <= 0 ? 0 : value;
    }
    // -----------------------------------------------------------------------------------------------------------------
    // Methods
    // -----------------------------------------------------------------------------------------------------------------
    internal GeneratorStringBuilder BuilderAction(Action action) {
        action();
        return this;
    }

    public GeneratorStringBuilder AppendUsings(string @using) => AppendLine($"using {@using};");
    public GeneratorStringBuilder AppendUsings(params string[] usings) => AppendMultipleUsings(usings);
    public GeneratorStringBuilder AppendMultipleUsings(params IEnumerable<string>[] usings) => ForEach(
            new HashSet<string>(usings.SelectMany(u => u)),
            (builder, s) => builder.AppendUsings(s)
    );

    public GeneratorStringBuilder AppendAutoGenerated() => AppendLineComment("<auto-generated />");
    public GeneratorStringBuilder AppendComment(string comment) => Append($" // {comment}");
    public GeneratorStringBuilder AppendLineComment(string comment) => AppendLine($"// {comment}");
    public GeneratorStringBuilder AppendNamespace(string name) => AppendLine($"namespace {name};");
    public GeneratorStringBuilder AppendNullableEnable() => AppendLine("#nullable enable");

    #region Append (straight stringbuilder)
    public GeneratorStringBuilder Append(char c) => BuilderAction(() => _builder.Append(c));
    public GeneratorStringBuilder Append(string text) => BuilderAction(() => _builder.Append(text));
    #endregion

    #region AppendLine methods(stringbuilder + indent)
    public GeneratorStringBuilder AppendLine() => BuilderAction(() => _builder.AppendLine());
    public GeneratorStringBuilder AppendLine(string text) => BuilderAction(() => _builder
        .Append(IndentString(IndentAmount))
        .AppendLine(text)
    );
    #endregion

    #region Auto Indented methods
    internal string IndentString(int amount) => new(' ', amount * _paddingChars);

    public GeneratorStringBuilder Indent(Action<GeneratorStringBuilder> indentedAction) => BuilderAction(() => {
        IndentAmount++;
        indentedAction(this);
        IndentAmount--;
    });
    public GeneratorStringBuilder AppendLineIndented(string text) => Indent(g => g.AppendLine(text));

    public GeneratorStringBuilder AppendBody(string text) => BuilderAction(() => {
        string indent = IndentString(IndentAmount);// Cache the indent string
        int start = 0;
        for (int i = 0; i < text.Length; i++) {
            if (text[i] != '\r' && text[i] != '\n') continue;

            _builder.Append(indent).AppendLine(text.Substring(start, i - start));

            if (text[i] == '\r' && i + 1 < text.Length && text[i + 1] == '\n') { i++; }
            start = i + 1;
        }

        // Append the last line if text does not end with a newline
        if (start < text.Length) {
            _builder.Append(indent).AppendLine(text[start..]);
        }
    });

    public GeneratorStringBuilder AppendBodyIndented(string text) => Indent(g => g.AppendBody(text));
    #endregion

    #region ForEach
    public GeneratorStringBuilder ForEachAppendLine(IEnumerable<string> items) => ForEach(items, itemFormatter: (g, item) => g.AppendLine(item));
    public GeneratorStringBuilder ForEachAppendLine<T>(IEnumerable<T> items, Func<T, string> itemFormatter) => ForEach(
        items,
        itemFormatter: (g, item) => g.AppendLine(itemFormatter(item))
    );

    public GeneratorStringBuilder ForEachAppendLineIndented(IEnumerable<string> items) => ForEach(items, itemFormatter: (g, item) => g.AppendLineIndented(item));
    public GeneratorStringBuilder ForEachAppendLineIndented<T>(IEnumerable<T> items, Func<T, string> itemFormatter) => ForEach(
        items,
        itemFormatter: (g, item) => g.AppendLineIndented(itemFormatter(item))
    );

    public GeneratorStringBuilder ForEachAppendBody(IEnumerable<string> items) => ForEach(items, itemFormatter: (g, item) => g.AppendBody(item));
    public GeneratorStringBuilder ForEachAppendBody<T>(IEnumerable<T> items, Func<T, string> itemFormatter) => ForEach(
        items,
        itemFormatter: (g, item) => g.AppendBody(itemFormatter(item))
    );

    public GeneratorStringBuilder ForEach<T>(IEnumerable<T> items, Action<GeneratorStringBuilder, T> itemFormatter) => BuilderAction(() => {
        if (items is ICollection<T> { Count: 0 }) return;// Skip iteration if no items
        foreach (T item in items) itemFormatter(this, item);
    });
    #endregion

    #region ToString & Clear
    public override string ToString() => _builder.ToString();

    public string ToStringAndClear() {
        string result = ToString();
        Clear();
        return result;
    }

    public GeneratorStringBuilder Clear() {
        _builder.Clear();
        IndentAmount = 0;
        return this;
    }
    #endregion
}
